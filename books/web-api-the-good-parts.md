# Web API: The Good Parts

https://www.oreilly.co.jp/books/9784873116860/

O'REILLY JAPAN
水野 貴明 著

## 2章 エンドポイントの設計とリクエストの形式

### 2.1 APIとして公開する機能を設計する。

- クライアントアプリケーションの画面とその遷移を考える。
- すべての機能を個別のAPIとして実装するのはあまり良い方法ではない。1つにまとめられる機能があるかもしれない。
- エンドポイントを考えながらAPIを整理する。

### 2.2 APIエンドポイントの考え方

- 人間が読んで理解できるURIにする。
  - むやみに省略形を使わない。国際規格として標準化されているものはむしろ使ったほうがわかりやすい。
  - APIでよく使われている英単語を使う。
- 基本はすべて小文字を使う。大文字小文字の混在はAPIを間違えやすくする。
- サーバ側の都合はサーバ内で処理をして、利用者にそれを意識させない。
- サーバ側のアーキテクチャを反映しない。利用者にとってはAPIのサーバがPHPで書かれていようとCOBOLで書かれていようとまったく関係がない。

### 2.3 HTTPメソッドとエンドポイント

- メソッドはAPIで取得するリソースをどう操作するのかを表すもの。
  - サーバの情報を取得するために利用するGET
  - サーバの情報を修正するために利用するPOST
  - 更新したいリソースのURIそのものを指定し、その内容を書き換えるPUT
  - リソースの削除を行うDELETE
  - リソースの一部だけを更新したい場合に使うPATCH

### 2.4 APIのエンドポイント設計

|目的|エンドポイント|メソッド|
|---|---|---|
|ユーザー一覧取得|https://api.example.com/v1/users|GET|
|ユーザーの新規登録|https://api.example.com/v1/users|POST|
|特定のユーザーの情報の取得|https://api.example.com/v1/users/:id|GET|
|ユーザーの情報の更新|https://api.example.com/v1/users/:id|PUT/PATCH|
|ユーザーの情報の削除|https://api.example.com/v1/users/:id|DELETE|

上記のエンドポイント設計でカバーできるのは以下のもの。

- ユーザー登録
- 自分の情報の取得
- 自分の情報の更新
- ユーザー情報の取得
- ユーザーの検索

APIとしては5つになっているが、エンドポイントは2つだけ。  
ユーザーの検索は、ユーザー一覧の取得APIに対してクエリパラメータで絞り込みを行うことで実現する。  

### 2.5 検索とクエリパラメータの設計

#### 2.5.5 クエリパラメータとパスの使い分け

- 一意なリソースを表すのに必要な情報かどうか
- 省略可能かどうか

ユーザーIDの場合、ユーザーIDを指定することで参照したい情報が一意に決まるのでパスに入れたほうがいい。  
アクセストークンなどは利用者の認可が目的であり、リソースとは無関係なのでクエリパラメータのほうが適している。  
リストや検索の際のoffset、limit、pageなどのパラメータは省略すればデフォルトの値が利用されるケースが多く、クエリパラメータのほうが適している。  

### 2.6 ログインとOAuth 2.0

#### 2.6.1 アクセストークンの有効期限と更新

アクセストークンを取得した際のレスポンスデータに有効期限を含める。  
有効期限が切れた場合、サーバはinvalid_tokenというステータスコード401のエラーを返す。  
invalid_tokenが発生した際にはリフレッシュトークンを使ってアクセストークンを再度要求することができる。  
リフレッシュトークンは、アクセストークンを再発行してもらうための別のトークンで、アクセストークンと同時に取得できる。
リフレッシュの際のリクエストは、grant_typeにrefresh_tokenを指定して、refresh_tokenとともに返信する。

## 3章 レスポンスデータの設計

### 3.3.4 配列とフォーマット
APIで配列を返したいケースでは、配列をそのまま返す方法と、レスポンス全体をオブジェクトにしてその中に配列を入れる方法がある。  
オブジェクトで包んだ記述方法のほうがおすすめ。
- レスポンスデータが何を示しているかがわかりやすくなる。
- レスポンスデータをオブジェクトに統一することができる。
- セキュリティ上のリスクを避けることができる。
  - トップレベルが配列であるJSONは、JSONインジェクションという脆弱性に対するリスクが大きくなる。
